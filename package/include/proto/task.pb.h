// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: task.proto

#ifndef PROTOBUF_task_2eproto__INCLUDED
#define PROTOBUF_task_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace blaze {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_task_2eproto();
void protobuf_AssignDesc_task_2eproto();
void protobuf_ShutdownFile_task_2eproto();

class DataMsg;
class TaskMsg;

enum MsgType {
  ACCREQUEST = 0,
  ACCGRANT = 1,
  ACCREJECT = 2,
  ACCFINISH = 3,
  ACCDATA = 4,
  ACCFAILURE = 5,
  ACCBROADCAST = 6,
  ACCTERM = 7
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = ACCREQUEST;
const MsgType MsgType_MAX = ACCTERM;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
// ===================================================================

class DataMsg : public ::google::protobuf::Message {
 public:
  DataMsg();
  virtual ~DataMsg();

  DataMsg(const DataMsg& from);

  inline DataMsg& operator=(const DataMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataMsg& default_instance();

  void Swap(DataMsg* other);

  // implements Message ----------------------------------------------

  DataMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataMsg& from);
  void MergeFrom(const DataMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 partition_id = 1;
  inline bool has_partition_id() const;
  inline void clear_partition_id();
  static const int kPartitionIdFieldNumber = 1;
  inline ::google::protobuf::int64 partition_id() const;
  inline void set_partition_id(::google::protobuf::int64 value);

  // optional bool cached = 2;
  inline bool has_cached() const;
  inline void clear_cached();
  static const int kCachedFieldNumber = 2;
  inline bool cached() const;
  inline void set_cached(bool value);

  // optional bool sampled = 3;
  inline bool has_sampled() const;
  inline void clear_sampled();
  static const int kSampledFieldNumber = 3;
  inline bool sampled() const;
  inline void set_sampled(bool value);

  // optional int32 element_length = 4;
  inline bool has_element_length() const;
  inline void clear_element_length();
  static const int kElementLengthFieldNumber = 4;
  inline ::google::protobuf::int32 element_length() const;
  inline void set_element_length(::google::protobuf::int32 value);

  // optional int32 element_size = 5;
  inline bool has_element_size() const;
  inline void clear_element_size();
  static const int kElementSizeFieldNumber = 5;
  inline ::google::protobuf::int32 element_size() const;
  inline void set_element_size(::google::protobuf::int32 value);

  // optional int32 num_elements = 6;
  inline bool has_num_elements() const;
  inline void clear_num_elements();
  static const int kNumElementsFieldNumber = 6;
  inline ::google::protobuf::int32 num_elements() const;
  inline void set_num_elements(::google::protobuf::int32 value);

  // optional int64 scalar_value = 7;
  inline bool has_scalar_value() const;
  inline void clear_scalar_value();
  static const int kScalarValueFieldNumber = 7;
  inline ::google::protobuf::int64 scalar_value() const;
  inline void set_scalar_value(::google::protobuf::int64 value);

  // optional string file_path = 8;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 8;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  inline void set_allocated_file_path(::std::string* file_path);

  // optional int64 file_size = 9;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 9;
  inline ::google::protobuf::int64 file_size() const;
  inline void set_file_size(::google::protobuf::int64 value);

  // optional int64 file_offset = 10;
  inline bool has_file_offset() const;
  inline void clear_file_offset();
  static const int kFileOffsetFieldNumber = 10;
  inline ::google::protobuf::int64 file_offset() const;
  inline void set_file_offset(::google::protobuf::int64 value);

  // optional string mask_path = 11;
  inline bool has_mask_path() const;
  inline void clear_mask_path();
  static const int kMaskPathFieldNumber = 11;
  inline const ::std::string& mask_path() const;
  inline void set_mask_path(const ::std::string& value);
  inline void set_mask_path(const char* value);
  inline void set_mask_path(const char* value, size_t size);
  inline ::std::string* mutable_mask_path();
  inline ::std::string* release_mask_path();
  inline void set_allocated_mask_path(::std::string* mask_path);

  // @@protoc_insertion_point(class_scope:blaze.DataMsg)
 private:
  inline void set_has_partition_id();
  inline void clear_has_partition_id();
  inline void set_has_cached();
  inline void clear_has_cached();
  inline void set_has_sampled();
  inline void clear_has_sampled();
  inline void set_has_element_length();
  inline void clear_has_element_length();
  inline void set_has_element_size();
  inline void clear_has_element_size();
  inline void set_has_num_elements();
  inline void clear_has_num_elements();
  inline void set_has_scalar_value();
  inline void clear_has_scalar_value();
  inline void set_has_file_path();
  inline void clear_has_file_path();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_file_offset();
  inline void clear_has_file_offset();
  inline void set_has_mask_path();
  inline void clear_has_mask_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 partition_id_;
  bool cached_;
  bool sampled_;
  ::google::protobuf::int32 element_length_;
  ::google::protobuf::int32 element_size_;
  ::google::protobuf::int32 num_elements_;
  ::google::protobuf::int64 scalar_value_;
  ::std::string* file_path_;
  ::google::protobuf::int64 file_size_;
  ::google::protobuf::int64 file_offset_;
  ::std::string* mask_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static DataMsg* default_instance_;
};
// -------------------------------------------------------------------

class TaskMsg : public ::google::protobuf::Message {
 public:
  TaskMsg();
  virtual ~TaskMsg();

  TaskMsg(const TaskMsg& from);

  inline TaskMsg& operator=(const TaskMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskMsg& default_instance();

  void Swap(TaskMsg* other);

  // implements Message ----------------------------------------------

  TaskMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskMsg& from);
  void MergeFrom(const TaskMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .blaze.MsgType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::blaze::MsgType type() const;
  inline void set_type(::blaze::MsgType value);

  // optional string app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline const ::std::string& app_id() const;
  inline void set_app_id(const ::std::string& value);
  inline void set_app_id(const char* value);
  inline void set_app_id(const char* value, size_t size);
  inline ::std::string* mutable_app_id();
  inline ::std::string* release_app_id();
  inline void set_allocated_app_id(::std::string* app_id);

  // optional string acc_id = 3;
  inline bool has_acc_id() const;
  inline void clear_acc_id();
  static const int kAccIdFieldNumber = 3;
  inline const ::std::string& acc_id() const;
  inline void set_acc_id(const ::std::string& value);
  inline void set_acc_id(const char* value);
  inline void set_acc_id(const char* value, size_t size);
  inline ::std::string* mutable_acc_id();
  inline ::std::string* release_acc_id();
  inline void set_allocated_acc_id(::std::string* acc_id);

  // repeated .blaze.DataMsg data = 4;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::blaze::DataMsg& data(int index) const;
  inline ::blaze::DataMsg* mutable_data(int index);
  inline ::blaze::DataMsg* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::blaze::DataMsg >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::blaze::DataMsg >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:blaze.TaskMsg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_acc_id();
  inline void clear_has_acc_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* app_id_;
  ::std::string* acc_id_;
  ::google::protobuf::RepeatedPtrField< ::blaze::DataMsg > data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static TaskMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// DataMsg

// optional int64 partition_id = 1;
inline bool DataMsg::has_partition_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataMsg::set_has_partition_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataMsg::clear_has_partition_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataMsg::clear_partition_id() {
  partition_id_ = GOOGLE_LONGLONG(0);
  clear_has_partition_id();
}
inline ::google::protobuf::int64 DataMsg::partition_id() const {
  return partition_id_;
}
inline void DataMsg::set_partition_id(::google::protobuf::int64 value) {
  set_has_partition_id();
  partition_id_ = value;
}

// optional bool cached = 2;
inline bool DataMsg::has_cached() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataMsg::set_has_cached() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataMsg::clear_has_cached() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataMsg::clear_cached() {
  cached_ = false;
  clear_has_cached();
}
inline bool DataMsg::cached() const {
  return cached_;
}
inline void DataMsg::set_cached(bool value) {
  set_has_cached();
  cached_ = value;
}

// optional bool sampled = 3;
inline bool DataMsg::has_sampled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataMsg::set_has_sampled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataMsg::clear_has_sampled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataMsg::clear_sampled() {
  sampled_ = false;
  clear_has_sampled();
}
inline bool DataMsg::sampled() const {
  return sampled_;
}
inline void DataMsg::set_sampled(bool value) {
  set_has_sampled();
  sampled_ = value;
}

// optional int32 element_length = 4;
inline bool DataMsg::has_element_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataMsg::set_has_element_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataMsg::clear_has_element_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataMsg::clear_element_length() {
  element_length_ = 0;
  clear_has_element_length();
}
inline ::google::protobuf::int32 DataMsg::element_length() const {
  return element_length_;
}
inline void DataMsg::set_element_length(::google::protobuf::int32 value) {
  set_has_element_length();
  element_length_ = value;
}

// optional int32 element_size = 5;
inline bool DataMsg::has_element_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataMsg::set_has_element_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataMsg::clear_has_element_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataMsg::clear_element_size() {
  element_size_ = 0;
  clear_has_element_size();
}
inline ::google::protobuf::int32 DataMsg::element_size() const {
  return element_size_;
}
inline void DataMsg::set_element_size(::google::protobuf::int32 value) {
  set_has_element_size();
  element_size_ = value;
}

// optional int32 num_elements = 6;
inline bool DataMsg::has_num_elements() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataMsg::set_has_num_elements() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataMsg::clear_has_num_elements() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataMsg::clear_num_elements() {
  num_elements_ = 0;
  clear_has_num_elements();
}
inline ::google::protobuf::int32 DataMsg::num_elements() const {
  return num_elements_;
}
inline void DataMsg::set_num_elements(::google::protobuf::int32 value) {
  set_has_num_elements();
  num_elements_ = value;
}

// optional int64 scalar_value = 7;
inline bool DataMsg::has_scalar_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataMsg::set_has_scalar_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataMsg::clear_has_scalar_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataMsg::clear_scalar_value() {
  scalar_value_ = GOOGLE_LONGLONG(0);
  clear_has_scalar_value();
}
inline ::google::protobuf::int64 DataMsg::scalar_value() const {
  return scalar_value_;
}
inline void DataMsg::set_scalar_value(::google::protobuf::int64 value) {
  set_has_scalar_value();
  scalar_value_ = value;
}

// optional string file_path = 8;
inline bool DataMsg::has_file_path() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataMsg::set_has_file_path() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataMsg::clear_has_file_path() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataMsg::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& DataMsg::file_path() const {
  return *file_path_;
}
inline void DataMsg::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void DataMsg::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void DataMsg::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMsg::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  return file_path_;
}
inline ::std::string* DataMsg::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataMsg::set_allocated_file_path(::std::string* file_path) {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    delete file_path_;
  }
  if (file_path) {
    set_has_file_path();
    file_path_ = file_path;
  } else {
    clear_has_file_path();
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 file_size = 9;
inline bool DataMsg::has_file_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataMsg::set_has_file_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataMsg::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataMsg::clear_file_size() {
  file_size_ = GOOGLE_LONGLONG(0);
  clear_has_file_size();
}
inline ::google::protobuf::int64 DataMsg::file_size() const {
  return file_size_;
}
inline void DataMsg::set_file_size(::google::protobuf::int64 value) {
  set_has_file_size();
  file_size_ = value;
}

// optional int64 file_offset = 10;
inline bool DataMsg::has_file_offset() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataMsg::set_has_file_offset() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataMsg::clear_has_file_offset() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataMsg::clear_file_offset() {
  file_offset_ = GOOGLE_LONGLONG(0);
  clear_has_file_offset();
}
inline ::google::protobuf::int64 DataMsg::file_offset() const {
  return file_offset_;
}
inline void DataMsg::set_file_offset(::google::protobuf::int64 value) {
  set_has_file_offset();
  file_offset_ = value;
}

// optional string mask_path = 11;
inline bool DataMsg::has_mask_path() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataMsg::set_has_mask_path() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataMsg::clear_has_mask_path() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataMsg::clear_mask_path() {
  if (mask_path_ != &::google::protobuf::internal::kEmptyString) {
    mask_path_->clear();
  }
  clear_has_mask_path();
}
inline const ::std::string& DataMsg::mask_path() const {
  return *mask_path_;
}
inline void DataMsg::set_mask_path(const ::std::string& value) {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  mask_path_->assign(value);
}
inline void DataMsg::set_mask_path(const char* value) {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  mask_path_->assign(value);
}
inline void DataMsg::set_mask_path(const char* value, size_t size) {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  mask_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMsg::mutable_mask_path() {
  set_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    mask_path_ = new ::std::string;
  }
  return mask_path_;
}
inline ::std::string* DataMsg::release_mask_path() {
  clear_has_mask_path();
  if (mask_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mask_path_;
    mask_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataMsg::set_allocated_mask_path(::std::string* mask_path) {
  if (mask_path_ != &::google::protobuf::internal::kEmptyString) {
    delete mask_path_;
  }
  if (mask_path) {
    set_has_mask_path();
    mask_path_ = mask_path;
  } else {
    clear_has_mask_path();
    mask_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TaskMsg

// required .blaze.MsgType type = 1;
inline bool TaskMsg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskMsg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskMsg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::blaze::MsgType TaskMsg::type() const {
  return static_cast< ::blaze::MsgType >(type_);
}
inline void TaskMsg::set_type(::blaze::MsgType value) {
  assert(::blaze::MsgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string app_id = 2;
inline bool TaskMsg::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskMsg::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskMsg::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskMsg::clear_app_id() {
  if (app_id_ != &::google::protobuf::internal::kEmptyString) {
    app_id_->clear();
  }
  clear_has_app_id();
}
inline const ::std::string& TaskMsg::app_id() const {
  return *app_id_;
}
inline void TaskMsg::set_app_id(const ::std::string& value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void TaskMsg::set_app_id(const char* value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void TaskMsg::set_app_id(const char* value, size_t size) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskMsg::mutable_app_id() {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    app_id_ = new ::std::string;
  }
  return app_id_;
}
inline ::std::string* TaskMsg::release_app_id() {
  clear_has_app_id();
  if (app_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_id_;
    app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskMsg::set_allocated_app_id(::std::string* app_id) {
  if (app_id_ != &::google::protobuf::internal::kEmptyString) {
    delete app_id_;
  }
  if (app_id) {
    set_has_app_id();
    app_id_ = app_id;
  } else {
    clear_has_app_id();
    app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string acc_id = 3;
inline bool TaskMsg::has_acc_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskMsg::set_has_acc_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskMsg::clear_has_acc_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskMsg::clear_acc_id() {
  if (acc_id_ != &::google::protobuf::internal::kEmptyString) {
    acc_id_->clear();
  }
  clear_has_acc_id();
}
inline const ::std::string& TaskMsg::acc_id() const {
  return *acc_id_;
}
inline void TaskMsg::set_acc_id(const ::std::string& value) {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  acc_id_->assign(value);
}
inline void TaskMsg::set_acc_id(const char* value) {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  acc_id_->assign(value);
}
inline void TaskMsg::set_acc_id(const char* value, size_t size) {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  acc_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskMsg::mutable_acc_id() {
  set_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    acc_id_ = new ::std::string;
  }
  return acc_id_;
}
inline ::std::string* TaskMsg::release_acc_id() {
  clear_has_acc_id();
  if (acc_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acc_id_;
    acc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskMsg::set_allocated_acc_id(::std::string* acc_id) {
  if (acc_id_ != &::google::protobuf::internal::kEmptyString) {
    delete acc_id_;
  }
  if (acc_id) {
    set_has_acc_id();
    acc_id_ = acc_id;
  } else {
    clear_has_acc_id();
    acc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .blaze.DataMsg data = 4;
inline int TaskMsg::data_size() const {
  return data_.size();
}
inline void TaskMsg::clear_data() {
  data_.Clear();
}
inline const ::blaze::DataMsg& TaskMsg::data(int index) const {
  return data_.Get(index);
}
inline ::blaze::DataMsg* TaskMsg::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::blaze::DataMsg* TaskMsg::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blaze::DataMsg >&
TaskMsg::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::blaze::DataMsg >*
TaskMsg::mutable_data() {
  return &data_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace blaze

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blaze::MsgType>() {
  return ::blaze::MsgType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_task_2eproto__INCLUDED
